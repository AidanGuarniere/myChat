#1: I will provide you with context on a software development task. If understood, proceed to #2
{
"context": {
  "overview": "I have a chatbox application that allows users to sign up/login(if prexisting user), submit messages to an API using the API key stored with their account, and store and view and interact with these conversations. Currently saving user API key to the User document of my database un-encrypted. API key is then added to NextAuth session for access clientside. Though there are auth requirements to interact with my DB, I would rather encrypt the API key so that it may be stored securely. Update my backend code to properly encrypt my API key without breaking the functioanlity of my application."
  "code": {
    "api/[...auth]":{
    "description":"backend authentication and session logic"
    "codeSnippet":"import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { MongoDBAdapter } from "@next-auth/mongodb-adapter";
import dbConnect from "../../../utils/dbConnect";
import User from "../../../models/UserSchema";
import bcrypt from "bcrypt";

const events = {
  error: async (message, object) => {
    console.error("NextAuth error:", message, object);
  },
};

async function comparePasswords(password, hashedPassword) {
  return await bcrypt.compare(password, hashedPassword);
}

async function validateUser(username, password) {
  const user = await User.findOne({ username });

  if (user && (await comparePasswords(password, user.password))) {
    return user;
  }

  return null;
}

const clientPromise = (async () => {
  const connection = await dbConnect();
  while (!connection?.s?.client) {
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  return connection.s.client;
})();

const authOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        const user = await validateUser(
          credentials.username,
          credentials.password
        );

        if (user) {
          const formattedUser = {
            id: user._id.toString(),
            username: user.username,
            apiKey: user.apiKey,
          };
          return Promise.resolve(formattedUser);
        } else {
          return Promise.reject(new Error("Invalid username or password."));
        }
      },
    }),
  ],
  events,
  errors: {
    async session() {
      return new Error("An error occurred while retrieving the session.");
    },
    async jwt() {
      return new Error("An error occurred while handling JWT.");
    },
  },
  adapter: MongoDBAdapter(clientPromise),

  session: {
    strategy: "jwt",
  },
  callbacks: {
    async signIn(user, account, profile) {
      return true;
    },
    async jwt({ token, trigger, user, session }) {
      if (user) {
        token.user = {
          id: user.id,
          username: user.username,
          apiKey: user.apiKey,
        };
      }
      if (trigger === "update" && session.apiKey) {
        token.user.apiKey = session.apiKey;
      }
      return token;
    },
    async session({ session, token }) {
      session.user = token.user;
      return Promise.resolve(session);
    },
  },
  pages: {
    error: "/auth/error",
  },
};
export default NextAuth(authOptions);

export { authOptions };
",
    },
    "api/gpt":{
    "description":"configures and facilitates api requests to gpt api (requires API key)"
    "codeSnippet":"import { Configuration, OpenAIApi } from "openai";

const fetchDataFromAPI = async (messages, apiKey) => {
  const configuration = new Configuration({
    apiKey,
  });
  const openai = new OpenAIApi(configuration);

  try {
    const completion = await openai.createChatCompletion({
      model: "gpt-3.5-turbo",
      messages: messages,
    });
    return completion.data;
  } catch (error) {
    console.error(error);
    throw error;
  }
};

export default async (req, res) => {
  const { messages, apiKey } = req.body;
  try {
    const completion = await fetchDataFromAPI(messages, apiKey);
    res.status(200).json({ completion });
  } catch (error) {
    const statusCode = error.status || 500;
    res.status(statusCode).json({ error: error.message });
  }
};
",
    },
    "api/users/updateApiKey":{
    "description":"interacts with user model to update api key"
    "codeSnippet":"// /pages/api/users/update-api-key.js
import dbConnect from "../../../utils/dbConnect";
import  User  from "../../../models/UserSchema";
import { authOptions } from "../auth/[...nextauth]";
import { getServerSession } from "next-auth/next";

dbConnect();

export default async function handler(req, res) {
  const { method } = req;

  if (method !== "PUT") {
    res.setHeader("Allow", ["PUT"]);
    return res.status(405).end(`Method ${method} Not Allowed`);
  }

  try {
    const session = await getServerSession(req, res, authOptions);
    if (!session) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const { newApiKey } = req.body;
    if (!newApiKey) {
      return res.status(400).json({ error: "New API key is required" });
    }

    const user = await User.findByIdAndUpdate(
      session.user.id,
      { apiKey: newApiKey },
      {
        new: true,
        runValidators: true,
      }
    );

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    return res.status(200).json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}
",
    },
    "api/signup":{
    "description":"api route for creating new user"
    "codeSnippet":"import { nanoid } from "nanoid";
import dbConnect from "../../utils/dbConnect.js";
import User from "../../models/UserSchema";

//u removed id, pretty sure u dont need it

export default async function handler(req, res) {
  dbConnect();

  if (req.method === "POST") {
    // Extract user data from the request
    const { username, password, openAIAPIKey } = req.body;
    try {
      // Check if the user already exists
      const existingUser = await User.findOne({ username });
      if (existingUser) {
        return res.status(400).json({ error: "Username is already taken." });
      }

      // Create a new user
      const newUser = new User({
        username,
        password, // Provide plain-text password
        apiKey: openAIAPIKey,
      });
      // Save the new user
      await newUser.save();

      // Return the created user (without the password)
      return res.status(201).json({
        user: {
          username: newUser.username,
          apiKey: newUser.apiKey,
        },
        credentials: {
          username: newUser.username,
          password: req.body.password,
        },
      });
    } catch (error) {
      console.error(error);
      res
        .status(500)
        .json({ error: "An error occurred while creating the user." });
    }
  } else {
    res.status(405).json({ error: "Method not allowed." });
  }
}
",
    },
    "models/UserSchema":{
    "description":""
    "codeSnippet":"const mongoose = require("mongoose");
const bcrypt = require("bcrypt");

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  apiKey: {
    type: String,
    required: true,
  },
});

userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) {
    return next();
  }
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

const User = mongoose.models.User || mongoose.model("User", userSchema);

module.exports = User;",
    },

  },
  "packageJson": {
  "name": "chatgpt-ui-template",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@next-auth/mongodb-adapter": "^1.1.1",
    "@next/font": "13.1.1",
    "@tailwindcss/typography": "^0.5.9",
    "axios": "^1.2.2",
    "bcrypt": "^5.1.0",
    "dotenv": "^16.0.3",
    "eslint": "8.31.0",
    "eslint-config-next": "13.1.1",
    "highlight.js": "^11.7.0",
    "lowlight": "^2.8.1",
    "mongoose": "^7.0.1",
    "nanoid": "^4.0.2",
    "next": "13.1.1",
    "next-auth": "^4.21.1",
    "openai": "^3.2.1",
    "react": "^18.2.0",
    "react-dom": "18.2.0",
    "react-lowlight": "^3.0.0",
    "react-syntax-highlighter": "^15.5.0",
    "rehype": "^12.0.1",
    "rehype-raw": "^6.1.1",
    "rehype-react": "^7.1.2",
    "rehype-sanitize": "^5.0.1",
    "remark": "^14.0.2",
    "remark-parse": "^10.0.1",
    "remark-react": "^9.0.1",
    "remark-rehype": "^10.1.0",
    "unified": "^10.1.2",
    "uuidv4": "^6.2.13"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.13",
    "postcss": "^8.4.21",
    "tailwindcss": "^3.2.6"
  }
}
,
  "additionalInfo": "Opt for whatever encryption method you think would be best, though we do want to avoid excessive loading time if possible"
}
}
#2: Please utilize the JSON template below to build an action plan based on the context provided in #1. 
Plan should include a step-by-step outline for the proposed code solution, detailing the logical flow and structure of the implementation. 
This plan should be presented in a clear and concise manner, enabling me to review and approve/reject the proposed approach before actually coding.
JSON Template:
{
  "projectContext": {
    "dependencies": {},
    "applicationDetails": "Relevant description of the code provided in context",
    "goal": "What is the user trying to do?",
    "desiredContext": "Request(s) for the user to provide additional info, if any"
  },
  "tasks": [
    {
      "id": 1,
      "type": "Task type",
      "name": "",
      "requirements": [
        {
          "id": 1,
          "description": "Requirement description"
        }
      ],
      "constraints": [
        {
          "id": 1,
          "description": "Constraint description"
        }
      ],
      "reasoning": "Explanation of how this task addresses the problem, including console messages if relevant"
    }
  ],
  "solution": "Explanation of the entire planned course of action, how it meets the user's goals, and why this is the optimal solution"
}


