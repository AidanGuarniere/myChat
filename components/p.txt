#1: I will provide you with context on a software development task. If understood, proceed to #2
{
"context": {
  "overview": "I have recently refactored the API of my Next.js chatbox app. The api is now stuctured /chats and /chats[id], but the utility functions I built to interact with the it were built just for /chats. please update utils/chatUtils to properly interact with our new API structure",
  "code": {
    "/api/chats": {
      "description": "API routes for all chats",
      "codeSnippet": "import dbConnect from "../../../utils/dbConnect";
import { Chat } from "../../../models/ChatSchema";
import { authOptions } from "../auth/[...nextauth]";
import { getServerSession } from "next-auth/next";

dbConnect();

export default async function handler(req, res) {
  const { method } = req;
  const session = await getServerSession(req, res, authOptions);
  if (!session) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }
  const userId = session.user.id;
  switch (method) {
    case "GET":
      try {
        const userChats = await Chat.find({ userId });
        res.status(200).json(userChats);
      } catch (error) {
        res.status(500).json({ error: "Internal Server Error" });
      }

      break;
    case "POST":
      try {
        const { title, messages } = req.body;
        const newChat = await Chat.create({ userId, title, messages });
        return res.status(201).json(newChat);
      } catch (error) {
        console.error(error);
        res.status(500).json({ error: "Internal Server Error" });
      }
      break;
    case "DELETE":
      try {
        const deletedChat = await Chat.deleteMany();
        res.status(200).json(deletedChat);
      } catch (error) {
        res.status(500).json({ error: "Internal Server Error" });
      }
    default:
      res.setHeader("Allow", ["GET", "POST", "DELETE"]);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
"
    },
    {
      "api/chats/titles:"route to get all chat titles",
    "codeSnippet":"import dbConnect from "../../../utils/dbConnect";
import { Chat } from "../../../models/ChatSchema";
import { authOptions } from "../auth/[...nextauth]";
import { getServerSession } from "next-auth/next";

dbConnect();

export default async function handler(req, res) {
  const { method } = req;
  const session = await getServerSession(req, res, authOptions);

  if (!session) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  const userId = session.user.id;

  switch (method) {
    case "GET":
      try {
        const userChats = await Chat.find({ userId }, "id title");
        res.status(200).json(userChats);
      } catch (error) {
        res.status(500).json({ error: "Internal Server Error" });
      }
      break;
    default:
      res.setHeader("Allow", ["GET"]);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
"
    },
        "/api/chats/[id]": {
      "description": "API routes for selected chat",
      "codeSnippet": "import dbConnect from "../../../utils/dbConnect";
import { Chat } from "../../../models/ChatSchema";
import { authOptions } from "../auth/[...nextauth]";
import { getServerSession } from "next-auth/next";

dbConnect();

export default async function handler(req, res) {
  const { method } = req;
  const session = await getServerSession(req, res, authOptions);

  if (!session) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  const userId = session.user.id;
  const { id: selectedChatId } = req.query;

  switch (method) {
    case "GET":
      try {
        const selectedChat = await Chat.findOne({ id: selectedChatId, userId });
        if (!selectedChat) {
          return res.status(404).json({ error: "Chat not found" });
        }
        return res.status(200).json(selectedChat);
      } catch (error) {
        res.status(500).json({ error: "Internal Server Error" });
      }
      break;
    case "PUT":
      try {
        const { title, messages } = req.body;

        if (id) {
          const updateData = {};
          if (title) updateData.title = title;
          if (messages) updateData.messages = messages;

          const updatedChat = await Chat.findOneAndUpdate(
            { id: selectedChatId, userId },
            updateData,
            { new: true }
          );

          if (!updatedChat) {
            return res.status(404).json({ error: "Chat not found" });
          }

          return res.status(200).json(updatedChat);
        } else {
          return res.status(400).json({ error: "ID is required" });
        }
      } catch (error) {
        console.error(error);
        res.status(500).json({ error: "Internal Server Error" });
      }
      break;
    case "DELETE":
      try {
        if (id) {
          const deletedChat = await Chat.deleteOne({
            id: selectedChatId,
            userId,
          });
          res.status(200).json(deletedChat);
        }
      } catch (error) {
        res.status(500).json({ error: "Internal Server Error" });
      }
      break;

    default:
      res.setHeader("Allow", ["GET", "PUT", "DELETE"]);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
"
    },
        "utils/chatUtils": {
      "description": "outdated Util functions to interact with /chats. should be updated to make use of new api structure ",
      "codeSnippet": "import axios from "axios";

// Fetches all chats
export const fetchChats = async () => {
  try {
    const response = await axios.get("/api/chats");
    if (response.data) {
      return response.data;
    }
  } catch (error) {
    console.error("Error fetching chats:", error);
    throw error;
  }
  return [];
};

export const fetchChatTitles = async () => {
  try {
    const response = await axios.get("/api/chats/titles");
    if (response.data) {
      return response.data;
    }
  } catch (error) {
    console.error("Error fetching chats:", error);
    throw error;
  }
  return [];
};
export const fetchChatContent = async () => {
  try {
    const response = await axios.get("/api/chats/contents");
    if (response.data) {
      return response.data;
    }
  } catch (error) {
    console.error("Error fetching chats:", error);
    throw error;
  }
  return [];
};

// Deletes all chats or a specific chat by id
export const deleteChats = async (id) => {
  if (id) {
    await axios.delete("/api/chats", { data: { id } });
  } else {
    await axios.delete("/api/chats");
  }
};

// Creates a new chat with the given data
export const createChat = async (chatData) => {
  try {
    const response = await axios.post("/api/chats", chatData);
    // fetchChats()
    return response.data;
  } catch (error) {
    console.error("Error creating chat:", error);
    throw error;
  }
};

// Updates an existing chat with the given data
export const updateChat = async (updatedChatData) => {
  try {
    const response = await axios.put("/api/chats", updatedChatData);
    // fetchChats()
    return response.data;
  } catch (error) {
    console.error("Error updating chat:", error);
    throw error;
  }
};
"
    }
  },
  "packageJson": {{
  "name": "chatgpt-ui-template",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@next-auth/mongodb-adapter": "^1.1.1",
    "@next/font": "13.1.1",
    "@tailwindcss/typography": "^0.5.9",
    "axios": "^1.2.2",
    "bcrypt": "^5.1.0",
    "dotenv": "^16.0.3",
    "eslint": "8.31.0",
    "eslint-config-next": "13.1.1",
    "highlight.js": "^11.7.0",
    "lowlight": "^2.8.1",
    "mongoose": "^7.0.1",
    "nanoid": "^4.0.2",
    "next": "13.1.1",
    "next-auth": "^4.21.1",
    "openai": "^3.2.1",
    "react": "^18.2.0",
    "react-dom": "18.2.0",
    "react-lowlight": "^3.0.0",
    "react-syntax-highlighter": "^15.5.0",
    "rehype": "^12.0.1",
    "rehype-raw": "^6.1.1",
    "rehype-react": "^7.1.2",
    "rehype-sanitize": "^5.0.1",
    "remark": "^14.0.2",
    "remark-parse": "^10.0.1",
    "remark-react": "^9.0.1",
    "remark-rehype": "^10.1.0",
    "unified": "^10.1.2",
    "uuidv4": "^6.2.13"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.13",
    "postcss": "^8.4.21",
    "tailwindcss": "^3.2.6"
  }
}
},
  "additionalInfo": "Make use of restful api practices."
}
}
#2: Please utilize the JSON template below to build a comprehensive action plan based on the context provided in #1. 
Plan should include a step-by-step outline for the proposed code solution, detailing the logical flow and structure of the implementation. 
This plan should be presented in a clear and concise manner, enabling me to review and approve/reject the proposed approach before actually coding.
JSON Template:
{
  "projectContext": {
    "dependencies": {},
    "applicationDetails": "Relevant description of the code provided in context",
    "goal": "What is the user trying to do?",
    "desiredContext": "Request(s) for the user to provide additional info, if any"
  },
  "tasks": [
    {
      "id": 1,
      "type": "Task type",
      "name": "",
      "requirements": [
        {
          "id": 1,
          "description": "Requirement description"
        }
      ],
      "constraints": [
        {
          "id": 1,
          "description": "Constraint description"
        }
      ],
      "reasoning": "Explanation of how this task addresses the problem, including console messages if relevant"
    }
  ],
  "solution": "Explanation of the entire planned course of action, how it meets the user's goals, and why this is the optimal solution"
}


